#include<stdio.h> 
#include<stdlib.h> 
#include<assert.h>
#define DateType int 

typedef struct Node {
	DateType data;
	struct Node* next;
}Node, *pNode;
void InitList(pNode *head)//初始化 
{
	assert(head); (*head) = NULL;
}
pNode BuyNode(DateType e)//申请新节点
{
	pNode lk = (pNode)malloc(sizeof(Node));
	if (!lk)
		return NULL;
	lk->data = e;
	return lk;
}
void PushBack(pNode *head, DateType e)//尾插
{
	pNode nd, tmp; assert(head);
	nd = BuyNode(e);
	if (!nd)
		return;
	else if (*head == NULL)
	{
		*head = nd; nd->next = NULL;
	}
	else
	{
		tmp = *head;
		while (tmp->next) { tmp = tmp->next; }
		tmp->next = nd; nd->next = NULL;
	}

}
void PopBack(pNode *head)//尾删 
{
	pNode tmp;
	pNode q = NULL;
	assert(head);
	if (*head == NULL) return;
	tmp = *head;
	while (tmp->next)
	{
		q = tmp; tmp = tmp->next;
	}
	if (q != NULL)//多个节点 
	{
		q->next = NULL;
		free(tmp);
	}
	else//一个节点 
	{
		free(tmp);
		*head = NULL;
	}
}
void PrintList(pNode head)//打印链表 
{
	pNode tmp = head;
	while (tmp)
	{
		printf("%d-->", tmp->data);
		tmp = tmp->next;
	} printf("NULL\n");
}
void PushFront(pNode *head, DateType e)//头插
{
	pNode nd = BuyNode(e);
	assert(head);
	if (nd)
	{
		nd->next = *head;
		*head = nd;
	}
}
void PopFront(pNode *head)//头删
{
	pNode tmp;
	assert(head);
	if (!*head) return;
	tmp = *head;
	*head = (*head)->next;
	free(tmp);
}
pNode Find(pNode head, DateType e)//找到指定元素的位置并返回,没找到返回NULL
{
	pNode tmp; assert(head);
	tmp = head;
	while (tmp->data != e)
	{
		tmp = tmp->next;
		if (tmp == NULL) return NULL;
	}
	return tmp;
}
void Inster(pNode *head, pNode pos, DateType e)//指定位置插入
{
	pNode nd;
	assert(head);
	if (pos && *head)
	{
		nd = BuyNode(e);
		nd->next = pos->next;
		pos->next = nd;
	}
}
void Erase(pNode *head, pNode pos)//指定位置删除 
{
	pNode tmp; pNode q = NULL;//q是记录tmp的前一个位置 
	assert(head); if (*head && pos)
	{
		tmp = *head;
		while (tmp != pos)
		{
			q = tmp;
			tmp = tmp->next;
		}
		if (q != NULL)
		{
			q->next = tmp->next;
			free(tmp);
		}
		else
		{
			free(tmp);
			*head = NULL;
		}

	}
}
int LenList(pNode head)//链表长度
{
	int count = 0;
	pNode tmp = head;
	while (tmp)
	{
		tmp = tmp->next;
		++count;
	}
	return count;
}
void Destroy(pNode *head)//销毁链表
{
	pNode tmp = *head;
	pNode del = NULL;
	while (tmp)
	{
		del = tmp;
		tmp = tmp->next;
		free(del);
		del = NULL;
	}
	*head = NULL;
}
void deleteNotTailNode(pNode pos)//删除一个无头单链表的非尾节点
{
	pNode posNext = NULL;
	assert(pos);
	if (pos == NULL || pos->next == NULL)
		return;
	posNext = pos->next;
	pos->data = posNext->data;
	pos->next = posNext->next;
	free(posNext);
	posNext = NULL;
}
void insetNothead(pNode pos, DateType d)//在无头单链表的一个节点（头结点处也可以，但麻烦了）前插入一个节点（不能用遍历）
{
	pNode pnewNode = (pNode)malloc(sizeof(Node));
	assert(pos);
	if (pos == NULL)
		return;
	pnewNode->next = pos->next;
	pnewNode->data = pos->data;
	pos->next = pnewNode;
	pos->data = d;
}
pNode yosephcircle(pNode phead, size_t num)//实现约瑟夫环算法
{
	int count = 0;
	pNode pcurNext = NULL;
	pNode pcur = NULL;
	assert(phead);
	if (phead == NULL || phead->next == NULL)//如果只有一个或0个元素，则不用开始
		return NULL;
	pcur = phead;
	while (pcur->next)//建环
	{
		pcur = pcur->next;
	}
	pcur->next = phead;
	pcur = phead;
	while (pcur->next != pcur)
	{
		count = num - 1;
		while (--count)
		{
			pcur = pcur->next;
		}
		pcurNext = pcur->next;
		pcur->next = pcurNext->next;
		free(pcurNext);
		pcurNext = NULL;
		pcur = pcur->next;
	}
	pcur->next = NULL;//解环
	return pcur;
}
void printlistlast(pNode head)//从后向前打印链表
{
	if (head)
	{
		printlistlast(head->next);
		printf("%d-->", head->data);
	}
}
void Destroylistlast(pNode* phead)//从后向前删除节点
{
	assert(phead);
	if (*phead)
	{
		Destroylistlast((*phead)->next);
		free(*phead);
		*phead = NULL;
	}
}
pNode findminNode(pNode phead)//遍历一次，找到中间节点
{
	pNode pslow = phead;
	pNode pfast = phead;
	while (pfast&&pfast->next)
	{
		pslow = pslow->next;
		pfast = pfast->next->next;
	}
	return pslow;
}

void reverselist(pNode *phead)//链表的逆置
{
	pNode pcur = NULL;
	pNode pcurNext = NULL;
	pNode pPre = NULL;
	assert(phead);
	if (phead == NULL || (*phead)->next == NULL)
		return;
	pPre = pcur = *phead;
	pcurNext = pcur->next;
	while (pcurNext)
	{
		pcur->next = pcurNext->next;
		pPre = pcurNext;
		pcurNext = pcurNext->next;
		pPre->next = (*phead);
		(*phead) = pPre;
	}
}

/***********测试代码1*****************/
void test1()
{
	pNode list;
	pNode pos;
	InitList(&list);
	PushBack(&list, 1);
	//1->NULL 
	PushBack(&list, 2);
	//1->2->NULL 
	PushBack(&list, 3);
	//1->2->3->NULL 
	PushFront(&list, 0);
	//0->1->2->3->NULL 
	PopFront(&list);
	//1->2->3->NULL 
	PrintList(list);
	//PopBack(&list); 
	//PopBack(&list);
	//1->2->NULL 
	//PopBack(&list);
	//1->NULL 
	//PopBack(&list);
	//NULL 
	//PushFront(&list,0);
	//0->NULL 
	//PopFront(&list);
	//NULL 
	//PrintList(list); 
	pos = Find(list, 2);
	Inster(&list, pos, 233);
	//1->2->233->3->NULL 
	PrintList(list);
	pos = Find(list, 233);
	Erase(&list, pos);
	//1->2->3->NULL 
	PrintList(list);
	PopBack(&list);
	PopBack(&list);
	//1->NULL 
	pos = Find(list, 1);
	Erase(&list, pos);
	//NULL 
	PrintList(list);
	Destroy(&list);
}
/***********测试代码2*****************/
void test2()
{
	pNode list;
	pNode pos;
	pNode q;
	InitList(&list);
	PushBack(&list, 1);
	//1->NULL 
	PushBack(&list, 2);
	//1->2->NULL 
	PushBack(&list, 3);
	//1->2->3->NULL 
	PrintList(list);
	pos = Find(list, 2);
	deleteNotTailNode(pos);
	//1->3->NULL
	PrintList(list);

	insetNothead(pos, 2);
	//1->2->3->NULL 
	PrintList(list);

	PushBack(&list, 4);
	PushBack(&list, 5);
	PushBack(&list, 6);
	PushBack(&list, 7);
	PrintList(list);
	//1->2->3->4->5->6->7->NULL 
	q = yosephcircle(list, 3);
	//出圈时序：3--6--2--7--5--1--4
	printf("%d\n", q->data);
	//q = yosephcircle(list, 4);
	//出圈时序：4--1--6--5--7--3--2
	//printf("%d\n", q->data);

	Destroy(&list);
	PrintList(list);
}
/***********测试代码3*****************/
void test3()
{
	pNode list;
	//pNode pos;
	pNode q;
	InitList(&list);
	PushBack(&list, 1);
	//1->NULL 
	PushBack(&list, 2);
	//1->2->NULL 
	PushBack(&list, 3);
	//1->2->3->NULL 
	printlistlast(list);
	//3-->2-->1
	printf("\n");

	//遍历一次，找到中间节点（test）
	PushBack(&list, 4);
	PushBack(&list, 5);
	PushBack(&list, 6);
	PushBack(&list, 7);
	PrintList(list);
	//1->2->3->4->5->6->7->NULL 
	q = findminNode(list);
	printf("%d\n", q->data);
	//4
	PushBack(&list, 8);
	PrintList(list);
	//1->2->3->4->5->6->7->8->NULL 
	q = findminNode(list);
	printf("%d\n", q->data);
	//5
	reverselist(&list);
	PrintList(list);
	//8->7->6->5->4->3->2->1->NULL 

	Destroylistlast(&list);
	PrintList(list);

}

/***********测试代码4****************/
/*
完成链表的以下操作：
// 使用冒泡对单链表进行排序
void BubbleSort(PNode pHead)

// 合并两个已序链表，合并之后新链表依然有序
PNode MergeList(PNode pHead1, PNode pHead2)

// 查找无头单链表的倒数第K个结点
PNode FindLastKNode(PNode pHead, int K)；

// 删除无头单链表的倒数第K个结点
PNode DeleteLastKNode(PNode pHead, int K)；

// 判断链表是否带环，如果带环求环的长度，并给出入口点
PNode HasCircle(PNode pHead)；
int GetCircleLen(PNode pHead)；
PNode GetEnterNode(PNode pHead, PNode pMeetNode)；
*/
void BubbleSort(pNode *pHead)// 使用冒泡对单链表进行排序
{
	pNode p = NULL, q = NULL, ptail = NULL;
	int cmp, tag = 0;
	assert(pHead);
	if (*pHead == NULL || (*pHead)->next == NULL)
		return;
	p = *pHead;
	q = *pHead;
	while (p)
	{
		q = *pHead;
		tag = 0;
		while (q->next != ptail)
		{
			if (q->data > q->next->data)
			{
				cmp = q->data;
				q->data = q->next->data;
				q->next->data = cmp;
				tag = 1;
			}
			q = q->next;
		}
		if (tag == 0)
			return;
		ptail = q;

		p = p->next;
	}
}

pNode MergeList(pNode pHead1, pNode pHead2)// 合并两个已序链表，合并之后新链表依然有序
{
	pNode pl1 = NULL, pl2 = NULL,pnewhead=NULL,ptail=NULL;
	assert(pHead1||pHead2);
	pl1 = pHead1;
	pl2 = pHead2;
	if (!pl1)
		return pl2;
	if (!pl2)
		return pl1;
	if (pl1->data < pl2->data)
	{
		pnewhead = pl1;
		ptail = pl1;
		pl1 = pl1->next;
	}
	else
	{
		pnewhead = pl2;
		ptail = pl2;
		pl2 = pl2->next;
	}
	while (pl1&&pl2)
	{
		if (pl1->data < pl2->data)
		{
			ptail->next  = pl1;
			ptail = pl1;
			pl1 = pl1->next;
			
		}
		else
		{
			ptail->next  = pl2;
			ptail = pl2;
			pl2 = pl2->next;
			
		}
	}
	if (!pl1)
		ptail->next = pl2;
	else ptail->next = pl1;
	return pnewhead;
}

pNode FindLastKNode(pNode pHead, int K)// 查找无头单链表的倒数第K个结点
{
	pNode pleft = NULL, pright = NULL;
	assert(pHead);
	if (pHead == NULL|| K <= 0)
		return NULL;
	pleft = pright = pHead;
	while (--K)
	{
		if (pright->next == NULL)
			return NULL;
		pright = pright->next;
	}
	while (pright->next !=NULL)
	{
		pright = pright->next;
		pleft = pleft->next;
	}
	return pleft;
}


pNode DeleteLastKNode(pNode pHead, int K)// 删除无头单链表的倒数第K个结点
{
	pNode pdelnode = NULL, pdelleftnode = NULL;
	pdelnode=FindLastKNode(pHead, K);
	if (pdelnode == NULL)
	{
		printf("要删除的节点不存在！！！\n");
		return NULL;
	}
	else if (pdelnode == pHead)
	{
		pdelleftnode = pdelnode;
		pHead = pHead->next;
		free(pdelnode);
		pdelnode = NULL;
	}
	else
	{
		pdelleftnode = FindLastKNode(pHead, K+1);
		pdelleftnode->next = pdelnode->next;
		free(pdelnode);
		pdelnode = NULL;
	}
	return pHead;
}

// 判断链表是否带环，如果带环求环的长度，并给出入口点
pNode HasCircle(pNode pHead)//判断链表是否带环
{
	pNode  pleft = NULL, pright = NULL;
	assert(pHead);
	if (pHead == NULL || pHead->next == NULL)
		return NULL;
	pleft = pHead;
	pright = pHead->next;
	while (pright || pright->next)
	{
		if (pleft != pright)
		{
			pleft = pleft->next;
			pright = pright->next->next;
		}
		else return pleft;
	}
	return NULL;
}
int GetCircleLen(pNode pHead)//如果带环,求环的长度
{
	pNode ptail=HasCircle(pHead);
	pNode q = ptail->next ;
	int counter=1;
	assert(pHead);

	if (ptail == NULL)
		return 0;
	while (q != ptail)
	{
		counter++;
		q = q->next;
	}
	return counter;
}
pNode GetEnterNode(pNode pHead, pNode pMeetNode)//给出带环入口点
{
	pNode  ptail = NULL, q = NULL;
	ptail =pMeetNode;
	q = pHead;
	while (q==ptail)
	{
		q = q->next;
		ptail = ptail->next;
	}
	return q;
}
void test4()
{

	pNode list1;
	pNode list2;
	pNode pos;
	pNode q;
	InitList(&list1);
	PushBack(&list1,7);
	//7->NULL 
	PushBack(&list1, 5);
	//7->5->NULL 
	PushBack(&list1, 3);
	//7->5->3->NULL 
	PrintList(list1);

	InitList(&list2);
	PushBack(&list2, 1);
	//1->NULL 
	PushBack(&list2, 4);
	//1->4->NULL 
	PushBack(&list2, 8);
	//1->4->8->NULL 
	PrintList(list2);

	BubbleSort(&list1);
	PrintList(list1);
	//3->5->7->NULL 

	q=MergeList(list1,list2);
	PrintList(q);
	//1->3->4->5->7->8->NULL 

	pos=FindLastKNode(q,2);
	if (pos == NULL)
		printf("没有找到合适的值！！！\n");
	else printf("%d\n",pos->data);
	//7

	pos=DeleteLastKNode(q, 2);
	if (pos == NULL)
		printf("没能删除合适的值！！！\n");
	else 	PrintList(pos);
	//1->3->4->5->8->NULL 

}
int main()
{
	//test1();
	//test2();
	//test3();
	test4();
	system("pause");
	return 0;
}
